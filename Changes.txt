1.将临时变量的名字从t改为了_t，防止和变量重名；
2.将临时变量加入符号表，类型全为VarItem，都设置为integer，从而能够很方便的将临时变量插入到内存中；
3.ASSIGN之前进行了判断，如果标识符是const常量，就变成ASSIGN_I;
4.READ每次只能读取一个值，而不再是之前的读一串，等于说把原来的一个四元式根据读入数据的个数拆成了一堆READ四元式。则READ函数调用scanf只有两种，%c和%d；
5.LABEL改成两种，一种是普通标签的，一种是函数名标签的，用以区分函数名和普通标签名；
6.WRITE拆分，规则同READ，则WRITE调用printf只有三种，%s, %d, %c；
7.READ/WRITE变成五种：READINT/READCHAR/WRITEINT/WRITECHAR/WRITESTR,否则生成目标代码的时候还要判断一下WRITE的类型，比较麻烦；
8.函数/过程的header有误，_3_2_1_nowName，实际上应该是_1_2_3nowName；
9.调整了生成函数/过程标签的错误，应该在multiStatement()前生成，在multiStatement()后生成return；
10.既然主程序名字为MAIN，那么root节点的名字也应该为MAIN，所以将__ROOT__改为__MAIN__；
11.参数设置了PARA类型，自己分配了一套offset；
12.函数设置了offset；

TODO:
在栈中，压参数(实参的值，如果是引用则压地址，由caller完成)，压局部变量(callee)
删掉call之后的mov ..., eax一句，不再需要eax了
var影响了参数存储的内容



对于实参表，需要进行类型匹配的检查。(how?都有哪些种不匹配？比如表达式不能传给一个引用，而数组项是可以的，但是这些都怎么检查？)
tmp也有可能是char，而且是数组或函数返回值是才有可能。[solved]
函数调用时，函数也当作普通变量去查找，并且需要在函数里面建一个域，标记形参的类型和是否传址，然后才能进行参数匹配的检查。[solved]
拆分函数调用四元式

findAddr需要修改：要分为“参数，非参数”两种情况


para类型不同于局部变量，在栈上要分为参数域和局部变量域，所以除了标注类型，还要重新标注offset（且偏移根据参数出现次序依次标注，现在知道了为什么函数的参数要倒着压栈了，和数组倒着压栈是一个原理）

函数也要有偏移offset，因为函数返回值的方式是直接用赋值语句赋值，例如isOp = 1，所以直接把isOp当作一个普通变量去寻址，去赋值，这样的话eax寄存器也没用了，之前的在call完之后类似于mov j eax这样的语句也不需要了，直接把j = isOp(...)当作一个普通的变量isOp赋值给一个普通变量j的普通赋值语句处理

var传引用，接受者根据是否为引用来解释自己所保存的东西

//eax，调用子程序之前存到参数上方
